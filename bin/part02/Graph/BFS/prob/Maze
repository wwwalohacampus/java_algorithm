[미로찾기]
- 힙, 정적 메모리 모두 합쳐서 256MB이내, 스택 메모리 1MB 이내
- 제한시간 C/C++ : 1.5초 이내, JAVA : 2.5초 이내


세로 N, 가로 M 크기의 격자와 시작점(S_r, S_c)과 탈출구(E_r, E_c)아 주어졌을 때, 
시작점부터 탈출구까지 이동하기 위해 필요한 최소 이동횟수를 구하는 프로그램을 작성하시오.
한 번 이동 시 상하좌우로 한 칸씩만 이동할 수 있으며, 벽이 있는 지점은 이동할 수 없다.
만약 탈출구까지 이동할 수 있는 방법이 존재하지 않는다면 -1 을 출력한다.


[입력]
첫 번째 줄에서 테스트케이스의 수  T(1 ≤ T ≤ 10)가 주어진다.
각 테스트케이스마다 첫 번째 줄에는 세로의 길이 N과 가로의 길이 M을 공백을 두고 주어진다.(3 ≤ N, M ≤ 1000)
두 번째 줄에는 격자의 시작점(S_r, S_c)과 탈출구(E_r, E_c)를 나타내는  S_r, S_c, E_r, E_c가 각각 공백을 두고 주어진다.
각 좌표 쌍은 (행, 열)을 의미한다.
다음 N개의 줄에는 각 줄마다 M개의 숫자들이 공백을 두고 주어지는데 i번째 줄의 j번째 숫자는 격자의 (i,j)의 상태를 의미한다.
만약 값이 0인 경우 이동할 수 있는 곳이고, 1인 경우 이동할 수 없는 벽이 설치되어 있다은 뜻이다.


[출력]
각 줄마다 "#T"(T는 테스트케이스 번호)를 출력한 뒤, 공백을 두고 시작점부터 탈출구까지
이동하는데, 필요한 최소 횟수를 출력한다. 만약 도달할 수 없다면 -1을 출력한다.

[제한조건]
- 격자 밖으로 이동은 불가능하다.
- 시작점과 탈출구가 벽(1)인 경우는 없다.
- 좌측 상단의 좌표는 (1,1)이고 우측 하단의 좌표는 (N,M)이다.

[sample input]
2
3 4
3 1 1 4
0 0 1 0
0 1 0 0
0 0 0 1
10 7
1 1 7 7
0 0 0 0 0 0 0
0 1 1 1 1 1 0
0 1 1 1 1 0 0
0 0 0 1 1 0 1
0 1 0 1 1 0 0
0 1 0 1 1 1 0
0 1 0 0 0 0 0 
0 1 1 1 1 1 0
0 1 0 0 0 1 0
0 0 0 1 0 0 0

[sample output]
#1 5
#2 12
 
 
 *solution
 ""최소 이동횟수""	 --> BFS
 
 1. 입력
 - 테스트 케이스
 - N행, M열
 - 시작점(S_r,S_c), 도착점(E_r,E_c)


2. 탐색
*동남서북으로 탐색한다
- 이동지점이 격자 안에 있는지 확인
	- 방문가능한 곳인지 확인( 벽(1), 길(0) )
		→ 방문체크 
		→ 큐에 해당 정점을 추가


3. 이동횟수
- 방문할 때마다 이동횟수를 누적
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 